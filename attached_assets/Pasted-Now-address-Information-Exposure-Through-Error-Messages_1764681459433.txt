Now address Information Exposure Through Error Messages (Low) and improve error handling in DMIS so that end users never see sensitive internal details (stack traces, SQL, file paths), but logs remain useful.

Constraints:

Must not enable Flask debug mode in production.

Must keep enough logging for audit and troubleshooting, but avoid leaking secrets or internals to the browser.

Step 1 – Confirm debug configuration

Find where Flask app is created (likely drims_app.py or similar).

Ensure that debug is not enabled for production.

Confirm that configuration separates dev vs prod (e.g. via environment variables).

Step 2 – Implement centralized error handlers

Implement custom error handlers for at least:

400 (Bad Request)

403 (Forbidden)

404 (Not Found)

500 (Internal Server Error)

Example:

from flask import render_template  
 
@app.errorhandler(400)  
def bad_request(e):  
    return render_template("errors/400.html"), 400  
 
@app.errorhandler(403)  
def forbidden(e):  
    return render_template("errors/403.html"), 403  
 
@app.errorhandler(404)  
def not_found(e):  
    return render_template("errors/404.html"), 404  
 
@app.errorhandler(500)  
def internal_error(e):  
    # Log the exception with stack trace, but show a generic message  
    app.logger.exception("Internal server error")  
    return render_template("errors/500.html"), 500  


Create simple, non-verbose templates under templates/errors/ that:

Show generic messages (“An unexpected error occurred. Please contact support if this persists.”).

Do not display stack traces, SQL strings, file paths, or configuration details.

Step 3 – Remove internal details from user-facing messages

Search for:

flash( messages that contain technical details.

Direct use of str(e) from caught exceptions shown in templates.

Templates that render exception or debug info directly.

For any such cases:

Replace raw exception text with a user-friendly message.

Log the full exception using app.logger.exception(...) or logger.error(...) instead.

Example:

Before:

except Exception as e:  
    flash(f"Error while saving donation: {e}", "danger")  


After:

except Exception as e:  
    app.logger.exception("Error while saving donation")  
    flash("An error occurred while saving the donation. Please try again or contact support.", "danger")  

Step 4 – Keep UX and flows intact

Users should still receive clear feedback (success/failure) but not internal implementation details.

When done, summarise:

Which error handlers you added.

Where you changed user-facing messages to remove technical details.